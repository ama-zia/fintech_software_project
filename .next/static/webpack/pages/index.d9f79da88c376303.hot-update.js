"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./lib/forecast.ts":
/*!*************************!*\
  !*** ./lib/forecast.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildDailySeriesFromTransactions: function() { return /* binding */ buildDailySeriesFromTransactions; },\n/* harmony export */   forecast: function() { return /* binding */ forecast; }\n/* harmony export */ });\n// lib/forecast.ts\nfunction parseDateOnly(d) {\n    const t = new Date(d);\n    return new Date(t.getFullYear(), t.getMonth(), t.getDate());\n}\nfunction formatDate(d) {\n    return d.toISOString().slice(0, 10);\n}\n// Build daily series map from transactions (sum amounts per day)\nfunction buildDailySeriesFromTransactions(transactions) {\n    const map = {};\n    transactions.forEach((t)=>{\n        const day = formatDate(parseDateOnly(t.date));\n        map[day] = (map[day] || 0) + t.amount;\n    });\n    return map;\n}\n// Box-Muller for normal samples\nfunction randn() {\n    let mean = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, std = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n    let u = 0, v = 0;\n    while(u === 0)u = Math.random();\n    while(v === 0)v = Math.random();\n    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v) * std + mean;\n}\n/**\r\n * forecast(transactions, days, scenario)\r\n * - transactions: signed amounts (income positive, expenses negative)\r\n * - scenario: optional map category -> multiplier (0.0..2.0 etc)\r\n *\r\n * returns { points: ForecastPoint[], meta: { avgMonthly, projectedMonthly, ... } }\r\n */ async function forecast(transactions) {\n    let days = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 365, scenario = arguments.length > 2 ? arguments[2] : void 0;\n    const txsOriginal = transactions.map((t)=>({\n            ...t,\n            amount: Number(t.amount || 0)\n        }));\n    // ---------- compute historical avgMonthly ----------\n    let avgMonthly = 0;\n    if (txsOriginal.length > 0) {\n        const dates = txsOriginal.map((t)=>new Date(t.date));\n        const minDate = new Date(Math.min(...dates.map((d)=>d.getTime())));\n        const maxDate = new Date(Math.max(...dates.map((d)=>d.getTime())));\n        const months = Math.max(1, (maxDate.getFullYear() - minDate.getFullYear()) * 12 + (maxDate.getMonth() - minDate.getMonth() + 1));\n        const total = txsOriginal.reduce((s, t)=>s + t.amount, 0);\n        avgMonthly = total / months;\n    }\n    // ---------- compute baseline monthly per category ----------\n    const monthsSpan = (()=>{\n        if (txsOriginal.length === 0) return 1;\n        const dates = txsOriginal.map((t)=>new Date(t.date));\n        const minDate = new Date(Math.min(...dates.map((d)=>d.getTime())));\n        const maxDate = new Date(Math.max(...dates.map((d)=>d.getTime())));\n        return Math.max(1, (maxDate.getFullYear() - minDate.getFullYear()) * 12 + (maxDate.getMonth() - minDate.getMonth() + 1));\n    })();\n    const catTotals = {};\n    txsOriginal.forEach((t)=>{\n        const cat = (t.category || \"__uncategorized\").toString().trim();\n        catTotals[cat] = (catTotals[cat] || 0) + t.amount;\n    });\n    const baselineMonthlyByCategory = {};\n    Object.keys(catTotals).forEach((cat)=>{\n        baselineMonthlyByCategory[cat] = catTotals[cat] / monthsSpan;\n    });\n    // projectedMonthly by applying scenario multipliers\n    const projectedMonthlyByCategory = Object.keys(baselineMonthlyByCategory).reduce((sum, cat)=>{\n        const multiplier = scenario && cat in scenario ? scenario[cat] : 1;\n        return sum + baselineMonthlyByCategory[cat] * multiplier;\n    }, 0);\n    // ---------- apply scenario multipliers ----------\n    const txsAdjusted = txsOriginal.map((t)=>{\n        const multiplier = scenario && t.category && t.category in scenario ? scenario[t.category] : 1;\n        return {\n            ...t,\n            amount: t.amount * multiplier\n        };\n    });\n    // ---------- build daily net flow ----------\n    const map = buildDailySeriesFromTransactions(txsAdjusted);\n    const dates = Object.keys(map).sort();\n    if (dates.length === 0) {\n        const points = [];\n        const today = new Date();\n        for(let i = 0; i < days; i++){\n            const d = new Date(today);\n            d.setDate(d.getDate() + i);\n            points.push({\n                date: formatDate(d),\n                median: 0,\n                lower: 0,\n                upper: 0\n            });\n        }\n        return {\n            points,\n            meta: {\n                notes: \"no data\",\n                avgMonthly: 0,\n                projectedMonthly: 0\n            }\n        };\n    }\n    // ---------- convert to cumulative balance ----------\n    const dailyValues = dates.map((d)=>map[d]);\n    const cumulative = [];\n    dailyValues.reduce((acc, val)=>{\n        const newVal = acc + val;\n        cumulative.push(newVal);\n        return newVal;\n    }, 0);\n    const lastKnownBalance = cumulative[cumulative.length - 1];\n    // ---------- residual stats for noise ----------\n    const mean = cumulative.reduce((a, b)=>a + b, 0) / cumulative.length;\n    const std = Math.sqrt(cumulative.reduce((a, b)=>a + (b - mean) * (b - mean), 0) / Math.max(1, cumulative.length - 1));\n    // ---------- Monte Carlo sims on cumulative ----------\n    const sims = 300;\n    const runs = [];\n    for(let s = 0; s < sims; s++){\n        const run = [];\n        let bal = lastKnownBalance;\n        for(let i = 0; i < days; i++){\n            // approximate daily drift = avgMonthly/30\n            const dailyDrift = projectedMonthlyByCategory / 30;\n            const noise = Math.max(Math.min(randn(0, std / 10), std), -std);\n            bal = bal + dailyDrift + noise;\n            run.push(bal);\n        }\n        runs.push(run);\n    }\n    // ---------- compute quantiles ----------\n    const points = [];\n    for(let dayIdx = 0; dayIdx < days; dayIdx++){\n        const vals = runs.map((r)=>r[dayIdx]).sort((a, b)=>a - b);\n        const median = vals[Math.floor(vals.length / 2)];\n        const lower = vals[Math.floor(vals.length * 0.05)];\n        const upper = vals[Math.floor(vals.length * 0.95)];\n        const futDate = new Date(dates[dates.length - 1]);\n        futDate.setDate(futDate.getDate() + 1 + dayIdx);\n        points.push({\n            date: formatDate(futDate),\n            median,\n            lower,\n            upper\n        });\n    }\n    // forecast-based projected monthly (for diagnostics)\n    const first30 = points.slice(0, 30);\n    var _p_median;\n    const forecastDailyAvg = first30.length ? first30.reduce((s, p)=>s + ((_p_median = p.median) !== null && _p_median !== void 0 ? _p_median : 0), 0) / first30.length : 0;\n    const forecastProjectedMonthlyMC = forecastDailyAvg * 30;\n    return {\n        points,\n        meta: {\n            avgMonthly,\n            projectedMonthly: projectedMonthlyByCategory,\n            forecastProjectedMonthlyMC\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUtpRSxLQUFLLENBQUNGLEtBQUtuRCxNQUFNLEdBQUMsTUFBTTtRQUNoRCxNQUFNc0QsVUFBVSxJQUFJckYsS0FBS2dDLEtBQUssQ0FBQ0EsTUFBTUQsTUFBTSxHQUFDLEVBQUU7UUFDOUNzRCxRQUFRMUIsT0FBTyxDQUFDMEIsUUFBUWxGLE9BQU8sS0FBSyxJQUFJOEU7UUFDeEN6QixPQUFPSSxJQUFJLENBQUM7WUFBRWhELE1BQU1SLFdBQVdpRjtZQUFVeEI7WUFBUUM7WUFBT0M7UUFBTTtJQUNoRTtJQUVBLHFEQUFxRDtJQUNyRCxNQUFNdUIsVUFBVTlCLE9BQU9sRCxLQUFLLENBQUMsR0FBRztRQUVBaUY7SUFEaEMsTUFBTUMsbUJBQW1CRixRQUFRdkQsTUFBTSxHQUNsQ3VELFFBQVE5QyxNQUFNLENBQUMsQ0FBQ0MsR0FBRThDLElBQUk5QyxJQUFLOEMsQ0FBQUEsQ0FBQUEsWUFBQUEsRUFBRTFCLE1BQU0sY0FBUjBCLHVCQUFBQSxZQUFZLElBQUksS0FBS0QsUUFBUXZELE1BQU0sR0FDL0Q7SUFDSixNQUFNMEQsNkJBQTZCRCxtQkFBbUI7SUFFdEQsT0FBTztRQUNMaEM7UUFDQVEsTUFBTTtZQUNKbEM7WUFDQW9DLGtCQUFrQmY7WUFDbEJzQztRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZm9yZWNhc3QudHM/NTZjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsaWIvZm9yZWNhc3QudHNcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb24sIFNjZW5hcmlvRGVsdGEgfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEZvcmVjYXN0UG9pbnQgPSB7IGRhdGU6IHN0cmluZzsgbWVkaWFuOiBudW1iZXI7IGxvd2VyOiBudW1iZXI7IHVwcGVyOiBudW1iZXIgfTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlRGF0ZU9ubHkoZDogc3RyaW5nKSB7XHJcbiAgY29uc3QgdCA9IG5ldyBEYXRlKGQpO1xyXG4gIHJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksIHQuZ2V0TW9udGgoKSwgdC5nZXREYXRlKCkpO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZDogRGF0ZSkge1xyXG4gIHJldHVybiBkLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwxMCk7XHJcbn1cclxuXHJcbi8vIEJ1aWxkIGRhaWx5IHNlcmllcyBtYXAgZnJvbSB0cmFuc2FjdGlvbnMgKHN1bSBhbW91bnRzIHBlciBkYXkpXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZERhaWx5U2VyaWVzRnJvbVRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uW10pIDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB7XHJcbiAgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XHJcbiAgdHJhbnNhY3Rpb25zLmZvckVhY2godCA9PiB7XHJcbiAgICBjb25zdCBkYXkgPSBmb3JtYXREYXRlKHBhcnNlRGF0ZU9ubHkodC5kYXRlKSk7XHJcbiAgICBtYXBbZGF5XSA9IChtYXBbZGF5XSB8fCAwKSArIHQuYW1vdW50O1xyXG4gIH0pO1xyXG4gIHJldHVybiBtYXA7XHJcbn1cclxuXHJcbi8vIEJveC1NdWxsZXIgZm9yIG5vcm1hbCBzYW1wbGVzXHJcbmZ1bmN0aW9uIHJhbmRuKG1lYW49MCwgc3RkPTEpIHtcclxuICBsZXQgdSA9IDAsIHYgPSAwO1xyXG4gIHdoaWxlKHUgPT09IDApIHUgPSBNYXRoLnJhbmRvbSgpO1xyXG4gIHdoaWxlKHYgPT09IDApIHYgPSBNYXRoLnJhbmRvbSgpO1xyXG4gIHJldHVybiBNYXRoLnNxcnQoLTIuMCAqIE1hdGgubG9nKHUpKSAqIE1hdGguY29zKDIuMCAqIE1hdGguUEkgKiB2KSAqIHN0ZCArIG1lYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBmb3JlY2FzdCh0cmFuc2FjdGlvbnMsIGRheXMsIHNjZW5hcmlvKVxyXG4gKiAtIHRyYW5zYWN0aW9uczogc2lnbmVkIGFtb3VudHMgKGluY29tZSBwb3NpdGl2ZSwgZXhwZW5zZXMgbmVnYXRpdmUpXHJcbiAqIC0gc2NlbmFyaW86IG9wdGlvbmFsIG1hcCBjYXRlZ29yeSAtPiBtdWx0aXBsaWVyICgwLjAuLjIuMCBldGMpXHJcbiAqXHJcbiAqIHJldHVybnMgeyBwb2ludHM6IEZvcmVjYXN0UG9pbnRbXSwgbWV0YTogeyBhdmdNb250aGx5LCBwcm9qZWN0ZWRNb250aGx5LCAuLi4gfSB9XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZm9yZWNhc3QodHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvbltdLCBkYXlzID0gMzY1LCBzY2VuYXJpbz86IFNjZW5hcmlvRGVsdGEpIHtcclxuICBjb25zdCB0eHNPcmlnaW5hbCA9IHRyYW5zYWN0aW9ucy5tYXAodCA9PiAoeyAuLi50LCBhbW91bnQ6IE51bWJlcih0LmFtb3VudCB8fCAwKSB9KSk7XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0gY29tcHV0ZSBoaXN0b3JpY2FsIGF2Z01vbnRobHkgLS0tLS0tLS0tLVxyXG4gIGxldCBhdmdNb250aGx5ID0gMDtcclxuICBpZiAodHhzT3JpZ2luYWwubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3QgZGF0ZXMgPSB0eHNPcmlnaW5hbC5tYXAodCA9PiBuZXcgRGF0ZSh0LmRhdGUpKTtcclxuICAgIGNvbnN0IG1pbkRhdGUgPSBuZXcgRGF0ZShNYXRoLm1pbiguLi5kYXRlcy5tYXAoZCA9PiBkLmdldFRpbWUoKSkpKTtcclxuICAgIGNvbnN0IG1heERhdGUgPSBuZXcgRGF0ZShNYXRoLm1heCguLi5kYXRlcy5tYXAoZCA9PiBkLmdldFRpbWUoKSkpKTtcclxuICAgIGNvbnN0IG1vbnRocyA9IE1hdGgubWF4KFxyXG4gICAgICAxLFxyXG4gICAgICAobWF4RGF0ZS5nZXRGdWxsWWVhcigpIC0gbWluRGF0ZS5nZXRGdWxsWWVhcigpKSAqIDEyICtcclxuICAgICAgKG1heERhdGUuZ2V0TW9udGgoKSAtIG1pbkRhdGUuZ2V0TW9udGgoKSArIDEpXHJcbiAgICApO1xyXG4gICAgY29uc3QgdG90YWwgPSB0eHNPcmlnaW5hbC5yZWR1Y2UoKHMsdCkgPT4gcyArIHQuYW1vdW50LCAwKTtcclxuICAgIGF2Z01vbnRobHkgPSB0b3RhbCAvIG1vbnRocztcclxuICB9XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0gY29tcHV0ZSBiYXNlbGluZSBtb250aGx5IHBlciBjYXRlZ29yeSAtLS0tLS0tLS0tXHJcbiAgY29uc3QgbW9udGhzU3BhbiA9ICgoKSA9PiB7XHJcbiAgICBpZiAodHhzT3JpZ2luYWwubGVuZ3RoID09PSAwKSByZXR1cm4gMTtcclxuICAgIGNvbnN0IGRhdGVzID0gdHhzT3JpZ2luYWwubWFwKHQgPT4gbmV3IERhdGUodC5kYXRlKSk7XHJcbiAgICBjb25zdCBtaW5EYXRlID0gbmV3IERhdGUoTWF0aC5taW4oLi4uZGF0ZXMubWFwKGQgPT4gZC5nZXRUaW1lKCkpKSk7XHJcbiAgICBjb25zdCBtYXhEYXRlID0gbmV3IERhdGUoTWF0aC5tYXgoLi4uZGF0ZXMubWFwKGQgPT4gZC5nZXRUaW1lKCkpKSk7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoXHJcbiAgICAgIDEsXHJcbiAgICAgIChtYXhEYXRlLmdldEZ1bGxZZWFyKCkgLSBtaW5EYXRlLmdldEZ1bGxZZWFyKCkpICogMTIgK1xyXG4gICAgICAobWF4RGF0ZS5nZXRNb250aCgpIC0gbWluRGF0ZS5nZXRNb250aCgpICsgMSlcclxuICAgICk7XHJcbiAgfSkoKTtcclxuXHJcbiAgY29uc3QgY2F0VG90YWxzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XHJcbiAgdHhzT3JpZ2luYWwuZm9yRWFjaCh0ID0+IHtcclxuICAgIGNvbnN0IGNhdCA9ICh0LmNhdGVnb3J5IHx8IFwiX191bmNhdGVnb3JpemVkXCIpLnRvU3RyaW5nKCkudHJpbSgpO1xyXG4gICAgY2F0VG90YWxzW2NhdF0gPSAoY2F0VG90YWxzW2NhdF0gfHwgMCkgKyB0LmFtb3VudDtcclxuICB9KTtcclxuICBjb25zdCBiYXNlbGluZU1vbnRobHlCeUNhdGVnb3J5OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XHJcbiAgT2JqZWN0LmtleXMoY2F0VG90YWxzKS5mb3JFYWNoKGNhdCA9PiB7XHJcbiAgICBiYXNlbGluZU1vbnRobHlCeUNhdGVnb3J5W2NhdF0gPSBjYXRUb3RhbHNbY2F0XSAvIG1vbnRoc1NwYW47XHJcbiAgfSk7XHJcblxyXG4gIC8vIHByb2plY3RlZE1vbnRobHkgYnkgYXBwbHlpbmcgc2NlbmFyaW8gbXVsdGlwbGllcnNcclxuICBjb25zdCBwcm9qZWN0ZWRNb250aGx5QnlDYXRlZ29yeSA9IE9iamVjdC5rZXlzKGJhc2VsaW5lTW9udGhseUJ5Q2F0ZWdvcnkpLnJlZHVjZSgoc3VtLCBjYXQpID0+IHtcclxuICAgIGNvbnN0IG11bHRpcGxpZXIgPSBzY2VuYXJpbyAmJiAoY2F0IGluIHNjZW5hcmlvKSA/IChzY2VuYXJpbyBhcyBhbnkpW2NhdF0gOiAxO1xyXG4gICAgcmV0dXJuIHN1bSArIGJhc2VsaW5lTW9udGhseUJ5Q2F0ZWdvcnlbY2F0XSAqIG11bHRpcGxpZXI7XHJcbiAgfSwgMCk7XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0gYXBwbHkgc2NlbmFyaW8gbXVsdGlwbGllcnMgLS0tLS0tLS0tLVxyXG4gIGNvbnN0IHR4c0FkanVzdGVkID0gdHhzT3JpZ2luYWwubWFwKHQgPT4ge1xyXG4gICAgY29uc3QgbXVsdGlwbGllciA9IHNjZW5hcmlvICYmIHQuY2F0ZWdvcnkgJiYgKHQuY2F0ZWdvcnkgaW4gc2NlbmFyaW8pID8gKHNjZW5hcmlvIGFzIGFueSlbdC5jYXRlZ29yeV0gOiAxO1xyXG4gICAgcmV0dXJuIHsgLi4udCwgYW1vdW50OiB0LmFtb3VudCAqIG11bHRpcGxpZXIgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLSBidWlsZCBkYWlseSBuZXQgZmxvdyAtLS0tLS0tLS0tXHJcbiAgY29uc3QgbWFwID0gYnVpbGREYWlseVNlcmllc0Zyb21UcmFuc2FjdGlvbnModHhzQWRqdXN0ZWQpO1xyXG4gIGNvbnN0IGRhdGVzID0gT2JqZWN0LmtleXMobWFwKS5zb3J0KCk7XHJcblxyXG4gIGlmIChkYXRlcy5sZW5ndGggPT09IDApIHtcclxuICAgIGNvbnN0IHBvaW50czogRm9yZWNhc3RQb2ludFtdID0gW107XHJcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XHJcbiAgICBmb3IgKGxldCBpPTA7aTxkYXlzO2krKyl7XHJcbiAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSh0b2RheSk7XHJcbiAgICAgIGQuc2V0RGF0ZShkLmdldERhdGUoKSArIGkpO1xyXG4gICAgICBwb2ludHMucHVzaCh7IGRhdGU6IGZvcm1hdERhdGUoZCksIG1lZGlhbjogMCwgbG93ZXI6IDAsIHVwcGVyOiAwIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgcG9pbnRzLCBtZXRhOiB7IG5vdGVzOiBcIm5vIGRhdGFcIiwgYXZnTW9udGhseTogMCwgcHJvamVjdGVkTW9udGhseTogMCB9IH07XHJcbiAgfVxyXG5cclxuICAvLyAtLS0tLS0tLS0tIGNvbnZlcnQgdG8gY3VtdWxhdGl2ZSBiYWxhbmNlIC0tLS0tLS0tLS1cclxuICBjb25zdCBkYWlseVZhbHVlcyA9IGRhdGVzLm1hcChkID0+IG1hcFtkXSk7XHJcbiAgY29uc3QgY3VtdWxhdGl2ZTogbnVtYmVyW10gPSBbXTtcclxuICBkYWlseVZhbHVlcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiB7XHJcbiAgICBjb25zdCBuZXdWYWwgPSBhY2MgKyB2YWw7XHJcbiAgICBjdW11bGF0aXZlLnB1c2gobmV3VmFsKTtcclxuICAgIHJldHVybiBuZXdWYWw7XHJcbiAgfSwgMCk7XHJcblxyXG4gIGNvbnN0IGxhc3RLbm93bkJhbGFuY2UgPSBjdW11bGF0aXZlW2N1bXVsYXRpdmUubGVuZ3RoIC0gMV07XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0gcmVzaWR1YWwgc3RhdHMgZm9yIG5vaXNlIC0tLS0tLS0tLS1cclxuICBjb25zdCBtZWFuID0gY3VtdWxhdGl2ZS5yZWR1Y2UoKGEsYik9PmErYiwwKSAvIGN1bXVsYXRpdmUubGVuZ3RoO1xyXG4gIGNvbnN0IHN0ZCA9IE1hdGguc3FydChjdW11bGF0aXZlLnJlZHVjZSgoYSxiKT0+YSsoYi1tZWFuKSooYi1tZWFuKSwwKSAvIE1hdGgubWF4KDEsIGN1bXVsYXRpdmUubGVuZ3RoLTEpKTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLSBNb250ZSBDYXJsbyBzaW1zIG9uIGN1bXVsYXRpdmUgLS0tLS0tLS0tLVxyXG4gIGNvbnN0IHNpbXMgPSAzMDA7XHJcbiAgY29uc3QgcnVuczogbnVtYmVyW11bXSA9IFtdO1xyXG4gIGZvciAobGV0IHM9MDtzPHNpbXM7cysrKXtcclxuICAgIGNvbnN0IHJ1bjogbnVtYmVyW10gPSBbXTtcclxuICAgIGxldCBiYWwgPSBsYXN0S25vd25CYWxhbmNlO1xyXG4gICAgZm9yIChsZXQgaT0wO2k8ZGF5cztpKyspe1xyXG4gICAgICAvLyBhcHByb3hpbWF0ZSBkYWlseSBkcmlmdCA9IGF2Z01vbnRobHkvMzBcclxuICAgICAgY29uc3QgZGFpbHlEcmlmdCA9IHByb2plY3RlZE1vbnRobHlCeUNhdGVnb3J5IC8gMzA7XHJcbiAgICAgIGNvbnN0IG5vaXNlID0gTWF0aC5tYXgoTWF0aC5taW4ocmFuZG4oMCxzdGQvMTApLCBzdGQpLCAtc3RkKTtcclxuICAgICAgYmFsID0gYmFsICsgZGFpbHlEcmlmdCArIG5vaXNlO1xyXG4gICAgICBydW4ucHVzaChiYWwpO1xyXG4gICAgfVxyXG4gICAgcnVucy5wdXNoKHJ1bik7XHJcbiAgfVxyXG5cclxuICAvLyAtLS0tLS0tLS0tIGNvbXB1dGUgcXVhbnRpbGVzIC0tLS0tLS0tLS1cclxuICBjb25zdCBwb2ludHM6IEZvcmVjYXN0UG9pbnRbXSA9IFtdO1xyXG4gIGZvciAobGV0IGRheUlkeCA9IDA7IGRheUlkeCA8IGRheXM7IGRheUlkeCsrKSB7XHJcbiAgICBjb25zdCB2YWxzID0gcnVucy5tYXAociA9PiByW2RheUlkeF0pLnNvcnQoKGEsYik9PmEtYik7XHJcbiAgICBjb25zdCBtZWRpYW4gPSB2YWxzW01hdGguZmxvb3IodmFscy5sZW5ndGgvMildO1xyXG4gICAgY29uc3QgbG93ZXIgPSB2YWxzW01hdGguZmxvb3IodmFscy5sZW5ndGgqMC4wNSldO1xyXG4gICAgY29uc3QgdXBwZXIgPSB2YWxzW01hdGguZmxvb3IodmFscy5sZW5ndGgqMC45NSldO1xyXG4gICAgY29uc3QgZnV0RGF0ZSA9IG5ldyBEYXRlKGRhdGVzW2RhdGVzLmxlbmd0aC0xXSk7XHJcbiAgICBmdXREYXRlLnNldERhdGUoZnV0RGF0ZS5nZXREYXRlKCkgKyAxICsgZGF5SWR4KTtcclxuICAgIHBvaW50cy5wdXNoKHsgZGF0ZTogZm9ybWF0RGF0ZShmdXREYXRlKSwgbWVkaWFuLCBsb3dlciwgdXBwZXIgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBmb3JlY2FzdC1iYXNlZCBwcm9qZWN0ZWQgbW9udGhseSAoZm9yIGRpYWdub3N0aWNzKVxyXG4gIGNvbnN0IGZpcnN0MzAgPSBwb2ludHMuc2xpY2UoMCwgMzApO1xyXG4gIGNvbnN0IGZvcmVjYXN0RGFpbHlBdmcgPSBmaXJzdDMwLmxlbmd0aFxyXG4gICAgPyAoZmlyc3QzMC5yZWR1Y2UoKHMscCk9PnMgKyAocC5tZWRpYW4gPz8gMCksIDApIC8gZmlyc3QzMC5sZW5ndGgpXHJcbiAgICA6IDA7XHJcbiAgY29uc3QgZm9yZWNhc3RQcm9qZWN0ZWRNb250aGx5TUMgPSBmb3JlY2FzdERhaWx5QXZnICogMzA7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBwb2ludHMsXHJcbiAgICBtZXRhOiB7XHJcbiAgICAgIGF2Z01vbnRobHksXHJcbiAgICAgIHByb2plY3RlZE1vbnRobHk6IHByb2plY3RlZE1vbnRobHlCeUNhdGVnb3J5LFxyXG4gICAgICBmb3JlY2FzdFByb2plY3RlZE1vbnRobHlNQ1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInBhcnNlRGF0ZU9ubHkiLCJkIiwidCIsIkRhdGUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImZvcm1hdERhdGUiLCJ0b0lTT1N0cmluZyIsInNsaWNlIiwiYnVpbGREYWlseVNlcmllc0Zyb21UcmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbnMiLCJtYXAiLCJmb3JFYWNoIiwiZGF5IiwiZGF0ZSIsImFtb3VudCIsInJhbmRuIiwibWVhbiIsInN0ZCIsInUiLCJ2IiwiTWF0aCIsInJhbmRvbSIsInNxcnQiLCJsb2ciLCJjb3MiLCJQSSIsImZvcmVjYXN0IiwiZGF5cyIsInNjZW5hcmlvIiwidHhzT3JpZ2luYWwiLCJOdW1iZXIiLCJhdmdNb250aGx5IiwibGVuZ3RoIiwiZGF0ZXMiLCJtaW5EYXRlIiwibWluIiwiZ2V0VGltZSIsIm1heERhdGUiLCJtYXgiLCJtb250aHMiLCJ0b3RhbCIsInJlZHVjZSIsInMiLCJtb250aHNTcGFuIiwiY2F0VG90YWxzIiwiY2F0IiwiY2F0ZWdvcnkiLCJ0b1N0cmluZyIsInRyaW0iLCJiYXNlbGluZU1vbnRobHlCeUNhdGVnb3J5IiwiT2JqZWN0Iiwia2V5cyIsInByb2plY3RlZE1vbnRobHlCeUNhdGVnb3J5Iiwic3VtIiwibXVsdGlwbGllciIsInR4c0FkanVzdGVkIiwic29ydCIsInBvaW50cyIsInRvZGF5IiwiaSIsInNldERhdGUiLCJwdXNoIiwibWVkaWFuIiwibG93ZXIiLCJ1cHBlciIsIm1ldGEiLCJub3RlcyIsInByb2plY3RlZE1vbnRobHkiLCJkYWlseVZhbHVlcyIsImN1bXVsYXRpdmUiLCJhY2MiLCJ2YWwiLCJuZXdWYWwiLCJsYXN0S25vd25CYWxhbmNlIiwiYSIsImIiLCJzaW1zIiwicnVucyIsInJ1biIsImJhbCIsImRhaWx5RHJpZnQiLCJub2lzZSIsImRheUlkeCIsInZhbHMiLCJyIiwiZmxvb3IiLCJmdXREYXRlIiwiZmlyc3QzMCIsInAiLCJmb3JlY2FzdERhaWx5QXZnIiwiZm9yZWNhc3RQcm9qZWN0ZWRNb250aGx5TUMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/forecast.ts\n"));

/***/ })

});