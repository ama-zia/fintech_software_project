"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./lib/forecast.ts":
/*!*************************!*\
  !*** ./lib/forecast.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildDailySeriesFromTransactions: function() { return /* binding */ buildDailySeriesFromTransactions; },\n/* harmony export */   forecast: function() { return /* binding */ forecast; }\n/* harmony export */ });\n// lib/forecast.ts\nfunction parseDateOnly(d) {\n    const t = new Date(d);\n    return new Date(t.getFullYear(), t.getMonth(), t.getDate());\n}\nfunction formatDate(d) {\n    return d.toISOString().slice(0, 10);\n}\n// Build daily series map from transactions (sum amounts per day)\nfunction buildDailySeriesFromTransactions(transactions) {\n    const map = {};\n    transactions.forEach((t)=>{\n        const day = formatDate(parseDateOnly(t.date));\n        map[day] = (map[day] || 0) + t.amount;\n    });\n    return map;\n}\n// Simple linear regression to detect trend\nfunction linearRegression(xs, ys) {\n    const n = xs.length;\n    if (n === 0) return {\n        slope: 0,\n        intercept: 0\n    };\n    const meanX = xs.reduce((a, b)=>a + b, 0) / n;\n    const meanY = ys.reduce((a, b)=>a + b, 0) / n;\n    let num = 0, den = 0;\n    for(let i = 0; i < n; i++){\n        num += (xs[i] - meanX) * (ys[i] - meanY);\n        den += (xs[i] - meanX) * (xs[i] - meanX);\n    }\n    const slope = den === 0 ? 0 : num / den;\n    const intercept = meanY - slope * meanX;\n    return {\n        slope,\n        intercept\n    };\n}\n// Box-Muller for normal samples\nfunction randn() {\n    let mean = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, std = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n    let u = 0, v = 0;\n    while(u === 0)u = Math.random();\n    while(v === 0)v = Math.random();\n    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v) * std + mean;\n}\n/**\r\n * forecast(transactions, options)\r\n * - transactions: array of transactions (date, amount)\r\n * - days: how many future days to simulate\r\n * - scenario: optional multiplier map category->multiplier to modify transactions before forecasting\r\n *\r\n * returns { points: ForecastPoint[], runs?: number[][], meta: { ... } }\r\n */ async function forecast(transactions) {\n    let days = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 365, scenario = arguments.length > 2 ? arguments[2] : void 0;\n    // 1) apply scenario multipliers (simple category multiplier)\n    const txs = transactions.map((t)=>{\n        let amount = t.amount;\n        // Apply scenario multiplier (scale up/down expenses/income)\n        if (scenario && t.category && t.category in scenario) {\n            var _scenario_t_category;\n            amount = amount * ((_scenario_t_category = scenario[t.category]) !== null && _scenario_t_category !== void 0 ? _scenario_t_category : 1);\n        }\n        return {\n            ...t,\n            amount\n        };\n    });\n    // compute avgMonthly (past) using min/max dates from txs\n    let avgMonthly = 0;\n    if (txs.length > 0) {\n        // ensure we parse dates and find min/max\n        const dates = txs.map((t)=>new Date(t.date));\n        const minDate = new Date(Math.min(...dates.map((d)=>d.getTime())));\n        const maxDate = new Date(Math.max(...dates.map((d)=>d.getTime())));\n        // months span (inclusive)\n        const months = Math.max(1, (maxDate.getFullYear() - minDate.getFullYear()) * 12 + (maxDate.getMonth() - minDate.getMonth() + 1));\n        const total = txs.reduce((s, tx)=>s + tx.amount, 0);\n        avgMonthly = total / months;\n    }\n    // 2) build daily series map and sort by day\n    const map = buildDailySeriesFromTransactions(txs);\n    const dates = Object.keys(map).sort();\n    // if there's no data, return zeros\n    if (dates.length === 0) {\n        const points = [];\n        const today = new Date();\n        for(let i = 0; i < days; i++){\n            const d = new Date(today);\n            d.setDate(d.getDate() + i);\n            points.push({\n                date: formatDate(d),\n                median: 0,\n                lower: 0,\n                upper: 0\n            });\n        }\n        return {\n            points,\n            meta: {\n                notes: \"no data\",\n                avgMonthly: 0,\n                projectedMonthly: 0\n            }\n        };\n    }\n    // convert to arrays for numerical ops\n    const values = dates.map((d)=>map[d]);\n    const n = values.length;\n    const xs = values.map((_, i)=>i);\n    // 3) fit linear regression for trend\n    const { slope, intercept } = linearRegression(xs, values);\n    // 4) weekday seasonality: average residual by weekday\n    const weekdaySums = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n    ];\n    const weekdayCount = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n    ];\n    for(let i = 0; i < n; i++){\n        const d = new Date(dates[i]);\n        const w = d.getDay();\n        const trendAtI = intercept + slope * i;\n        const residual = values[i] - trendAtI;\n        weekdaySums[w] += residual;\n        weekdayCount[w] += 1;\n    }\n    const weekdayAvg = weekdaySums.map((s, i)=>weekdayCount[i] ? s / weekdayCount[i] : 0);\n    // 5) compute residuals distribution (after removing trend+seasonality)\n    const residuals = [];\n    for(let i = 0; i < n; i++){\n        const d = new Date(dates[i]);\n        const w = d.getDay();\n        const pred = intercept + slope * i + weekdayAvg[w];\n        residuals.push(values[i] - pred);\n    }\n    const residMean = residuals.reduce((a, b)=>a + b, 0) / residuals.length;\n    const residStd = Math.sqrt(residuals.reduce((a, b)=>a + (b - residMean) * (b - residMean), 0) / Math.max(1, residuals.length - 1));\n    // 6) predictive median (deterministic trend+seasonality) + Monte Carlo sims\n    const sims = 300;\n    const runs = []; // simulations x days\n    for(let s = 0; s < sims; s++){\n        const run = [];\n        for(let i = 0; i < days; i++){\n            // future index = n + i\n            const idx = n + i;\n            const base = intercept + slope * idx;\n            // weekday for future day\n            const futDate = new Date(dates[dates.length - 1]);\n            futDate.setDate(futDate.getDate() + 1 + i);\n            const w = futDate.getDay();\n            const seasonal = weekdayAvg[w];\n            // sample residual noise\n            // clamp noise to ±3σ\n            const noise = Math.max(Math.min(randn(residMean, residStd), residStd * 3), -residStd * 3);\n            run.push(base + seasonal + noise);\n        }\n        runs.push(run);\n    }\n    // compute median and intervals for each day\n    const points = [];\n    for(let dayIdx = 0; dayIdx < days; dayIdx++){\n        const vals = runs.map((r)=>r[dayIdx]).sort((a, b)=>a - b);\n        const median = vals[Math.floor(vals.length / 2)];\n        const lower = vals[Math.floor(vals.length * 0.05)];\n        const upper = vals[Math.floor(vals.length * 0.95)];\n        const futDate = new Date(dates[dates.length - 1]);\n        futDate.setDate(futDate.getDate() + 1 + dayIdx);\n        points.push({\n            date: formatDate(futDate),\n            median,\n            lower,\n            upper\n        });\n    }\n    // projectedMonthly: average of first 30 median days (if available)\n    const first30 = points.slice(0, 30);\n    var _p_median;\n    const dailyAvg = first30.reduce((s, p)=>s + ((_p_median = p.median) !== null && _p_median !== void 0 ? _p_median : 0), 0) / first30.length;\n    const projectedMonthly = dailyAvg * 30; // approximate monthly\n    return {\n        points,\n        meta: {\n            slope,\n            intercept,\n            residStd,\n            residualCount: residuals.length,\n            avgMonthly,\n            projectedMonthly\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQTVDLE1BQU1DLFdBQVdGLFFBQVF4RSxNQUFNLENBQUMsQ0FBQ2dDLEdBQUV5QyxJQUFJekMsSUFBS3lDLENBQUFBLENBQUFBLFlBQUFBLEVBQUVoQyxNQUFNLGNBQVJnQyx1QkFBQUEsWUFBWSxJQUFJLEtBQUtELFFBQVE1RSxNQUFNO0lBQy9FLE1BQU1rRCxtQkFBbUI0QixXQUFXLElBQUksc0JBQXNCO0lBRTlELE9BQU87UUFDTHJDO1FBQ0FPLE1BQU07WUFDSi9DO1lBQ0FDO1lBQ0E2RDtZQUNBZ0IsZUFBZW5CLFVBQVU1RCxNQUFNO1lBQy9CMkI7WUFDQXVCO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9mb3JlY2FzdC50cz81NmNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9mb3JlY2FzdC50c1xyXG5pbXBvcnQgeyBUcmFuc2FjdGlvbiwgU2NlbmFyaW9EZWx0YSB9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5cclxudHlwZSBTZXJpZXNQb2ludCA9IHsgZGF0ZTogc3RyaW5nOyB2YWx1ZTogbnVtYmVyIH07XHJcbmV4cG9ydCB0eXBlIEZvcmVjYXN0UG9pbnQgPSB7IGRhdGU6IHN0cmluZzsgbWVkaWFuOiBudW1iZXI7IGxvd2VyOiBudW1iZXI7IHVwcGVyOiBudW1iZXIgfTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlRGF0ZU9ubHkoZDogc3RyaW5nKSB7XHJcbiAgY29uc3QgdCA9IG5ldyBEYXRlKGQpO1xyXG4gIHJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksIHQuZ2V0TW9udGgoKSwgdC5nZXREYXRlKCkpO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZDogRGF0ZSkge1xyXG4gIHJldHVybiBkLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwxMCk7XHJcbn1cclxuXHJcbi8vIEJ1aWxkIGRhaWx5IHNlcmllcyBtYXAgZnJvbSB0cmFuc2FjdGlvbnMgKHN1bSBhbW91bnRzIHBlciBkYXkpXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZERhaWx5U2VyaWVzRnJvbVRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uW10pIDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB7XHJcbiAgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XHJcbiAgdHJhbnNhY3Rpb25zLmZvckVhY2godCA9PiB7XHJcbiAgICBjb25zdCBkYXkgPSBmb3JtYXREYXRlKHBhcnNlRGF0ZU9ubHkodC5kYXRlKSk7XHJcbiAgICBtYXBbZGF5XSA9IChtYXBbZGF5XSB8fCAwKSArIHQuYW1vdW50O1xyXG4gIH0pO1xyXG4gIHJldHVybiBtYXA7XHJcbn1cclxuXHJcbi8vIFNpbXBsZSBsaW5lYXIgcmVncmVzc2lvbiB0byBkZXRlY3QgdHJlbmRcclxuZnVuY3Rpb24gbGluZWFyUmVncmVzc2lvbih4czogbnVtYmVyW10sIHlzOiBudW1iZXJbXSkge1xyXG4gIGNvbnN0IG4gPSB4cy5sZW5ndGg7XHJcbiAgaWYgKG4gPT09IDApIHJldHVybiB7IHNsb3BlOiAwLCBpbnRlcmNlcHQ6IDAgfTtcclxuICBjb25zdCBtZWFuWCA9IHhzLnJlZHVjZSgoYSxiKT0+YStiLDApL247XHJcbiAgY29uc3QgbWVhblkgPSB5cy5yZWR1Y2UoKGEsYik9PmErYiwwKS9uO1xyXG4gIGxldCBudW0gPSAwLCBkZW4gPSAwO1xyXG4gIGZvciAobGV0IGk9MDtpPG47aSsrKXtcclxuICAgIG51bSArPSAoeHNbaV0tbWVhblgpKih5c1tpXS1tZWFuWSk7XHJcbiAgICBkZW4gKz0gKHhzW2ldLW1lYW5YKSooeHNbaV0tbWVhblgpO1xyXG4gIH1cclxuICBjb25zdCBzbG9wZSA9IGRlbiA9PT0gMCA/IDAgOiBudW0vZGVuO1xyXG4gIGNvbnN0IGludGVyY2VwdCA9IG1lYW5ZIC0gc2xvcGUqbWVhblg7XHJcbiAgcmV0dXJuIHsgc2xvcGUsIGludGVyY2VwdCB9O1xyXG59XHJcblxyXG4vLyBCb3gtTXVsbGVyIGZvciBub3JtYWwgc2FtcGxlc1xyXG5mdW5jdGlvbiByYW5kbihtZWFuPTAsIHN0ZD0xKSB7XHJcbiAgbGV0IHUgPSAwLCB2ID0gMDtcclxuICB3aGlsZSh1ID09PSAwKSB1ID0gTWF0aC5yYW5kb20oKTtcclxuICB3aGlsZSh2ID09PSAwKSB2ID0gTWF0aC5yYW5kb20oKTtcclxuICByZXR1cm4gTWF0aC5zcXJ0KC0yLjAgKiBNYXRoLmxvZyh1KSkgKiBNYXRoLmNvcygyLjAgKiBNYXRoLlBJICogdikgKiBzdGQgKyBtZWFuO1xyXG59XHJcblxyXG4vKipcclxuICogZm9yZWNhc3QodHJhbnNhY3Rpb25zLCBvcHRpb25zKVxyXG4gKiAtIHRyYW5zYWN0aW9uczogYXJyYXkgb2YgdHJhbnNhY3Rpb25zIChkYXRlLCBhbW91bnQpXHJcbiAqIC0gZGF5czogaG93IG1hbnkgZnV0dXJlIGRheXMgdG8gc2ltdWxhdGVcclxuICogLSBzY2VuYXJpbzogb3B0aW9uYWwgbXVsdGlwbGllciBtYXAgY2F0ZWdvcnktPm11bHRpcGxpZXIgdG8gbW9kaWZ5IHRyYW5zYWN0aW9ucyBiZWZvcmUgZm9yZWNhc3RpbmdcclxuICpcclxuICogcmV0dXJucyB7IHBvaW50czogRm9yZWNhc3RQb2ludFtdLCBydW5zPzogbnVtYmVyW11bXSwgbWV0YTogeyAuLi4gfSB9XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZm9yZWNhc3QodHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvbltdLCBkYXlzID0gMzY1LCBzY2VuYXJpbz86IFNjZW5hcmlvRGVsdGEpIHtcclxuICAvLyAxKSBhcHBseSBzY2VuYXJpbyBtdWx0aXBsaWVycyAoc2ltcGxlIGNhdGVnb3J5IG11bHRpcGxpZXIpXHJcbiAgY29uc3QgdHhzID0gdHJhbnNhY3Rpb25zLm1hcCh0ID0+IHtcclxuICAgICAgICBsZXQgYW1vdW50ID0gdC5hbW91bnQ7XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IHNjZW5hcmlvIG11bHRpcGxpZXIgKHNjYWxlIHVwL2Rvd24gZXhwZW5zZXMvaW5jb21lKVxyXG4gICAgICAgIGlmIChzY2VuYXJpbyAmJiB0LmNhdGVnb3J5ICYmICh0LmNhdGVnb3J5IGluIHNjZW5hcmlvKSkge1xyXG4gICAgICAgIGFtb3VudCA9IGFtb3VudCAqIChzY2VuYXJpb1t0LmNhdGVnb3J5XSA/PyAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IC4uLnQsIGFtb3VudCB9O1xyXG5cclxuICAgIH0pO1xyXG5cclxuICAvLyBjb21wdXRlIGF2Z01vbnRobHkgKHBhc3QpIHVzaW5nIG1pbi9tYXggZGF0ZXMgZnJvbSB0eHNcclxuICBsZXQgYXZnTW9udGhseSA9IDA7XHJcbiAgaWYgKHR4cy5sZW5ndGggPiAwKSB7XHJcbiAgICAvLyBlbnN1cmUgd2UgcGFyc2UgZGF0ZXMgYW5kIGZpbmQgbWluL21heFxyXG4gICAgY29uc3QgZGF0ZXMgPSB0eHMubWFwKHQgPT4gbmV3IERhdGUodC5kYXRlKSk7XHJcbiAgICBjb25zdCBtaW5EYXRlID0gbmV3IERhdGUoTWF0aC5taW4oLi4uZGF0ZXMubWFwKGQgPT4gZC5nZXRUaW1lKCkpKSk7XHJcbiAgICBjb25zdCBtYXhEYXRlID0gbmV3IERhdGUoTWF0aC5tYXgoLi4uZGF0ZXMubWFwKGQgPT4gZC5nZXRUaW1lKCkpKSk7XHJcbiAgICAvLyBtb250aHMgc3BhbiAoaW5jbHVzaXZlKVxyXG4gICAgY29uc3QgbW9udGhzID0gTWF0aC5tYXgoMSwgKG1heERhdGUuZ2V0RnVsbFllYXIoKSAtIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSkgKiAxMiArIChtYXhEYXRlLmdldE1vbnRoKCkgLSBtaW5EYXRlLmdldE1vbnRoKCkgKyAxKSk7XHJcbiAgICBjb25zdCB0b3RhbCA9IHR4cy5yZWR1Y2UoKHMsIHR4KSA9PiBzICsgdHguYW1vdW50LCAwKTtcclxuICAgIGF2Z01vbnRobHkgPSB0b3RhbCAvIG1vbnRocztcclxuICB9XHJcblxyXG4gIC8vIDIpIGJ1aWxkIGRhaWx5IHNlcmllcyBtYXAgYW5kIHNvcnQgYnkgZGF5XHJcbiAgY29uc3QgbWFwID0gYnVpbGREYWlseVNlcmllc0Zyb21UcmFuc2FjdGlvbnModHhzKTtcclxuICBjb25zdCBkYXRlcyA9IE9iamVjdC5rZXlzKG1hcCkuc29ydCgpO1xyXG4gIC8vIGlmIHRoZXJlJ3Mgbm8gZGF0YSwgcmV0dXJuIHplcm9zXHJcbiAgaWYgKGRhdGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgY29uc3QgcG9pbnRzOiBGb3JlY2FzdFBvaW50W10gPSBbXTtcclxuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcclxuICAgIGZvciAobGV0IGk9MDtpPGRheXM7aSsrKXtcclxuICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKHRvZGF5KTtcclxuICAgICAgZC5zZXREYXRlKGQuZ2V0RGF0ZSgpICsgaSk7XHJcbiAgICAgIHBvaW50cy5wdXNoKHsgZGF0ZTogZm9ybWF0RGF0ZShkKSwgbWVkaWFuOiAwLCBsb3dlcjogMCwgdXBwZXI6IDAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBwb2ludHMsIG1ldGE6IHsgbm90ZXM6IFwibm8gZGF0YVwiLCBhdmdNb250aGx5OiAwLCBwcm9qZWN0ZWRNb250aGx5OiAwIH0gfTtcclxuICB9XHJcblxyXG4gIC8vIGNvbnZlcnQgdG8gYXJyYXlzIGZvciBudW1lcmljYWwgb3BzXHJcbiAgY29uc3QgdmFsdWVzID0gZGF0ZXMubWFwKGQgPT4gbWFwW2RdKTtcclxuICBjb25zdCBuID0gdmFsdWVzLmxlbmd0aDtcclxuICBjb25zdCB4cyA9IHZhbHVlcy5tYXAoKF8saSkgPT4gaSk7XHJcbiAgLy8gMykgZml0IGxpbmVhciByZWdyZXNzaW9uIGZvciB0cmVuZFxyXG4gIGNvbnN0IHsgc2xvcGUsIGludGVyY2VwdCB9ID0gbGluZWFyUmVncmVzc2lvbih4cywgdmFsdWVzKTtcclxuXHJcbiAgLy8gNCkgd2Vla2RheSBzZWFzb25hbGl0eTogYXZlcmFnZSByZXNpZHVhbCBieSB3ZWVrZGF5XHJcbiAgY29uc3Qgd2Vla2RheVN1bXM6IG51bWJlcltdID0gWzAsMCwwLDAsMCwwLDBdO1xyXG4gIGNvbnN0IHdlZWtkYXlDb3VudDogbnVtYmVyW10gPSBbMCwwLDAsMCwwLDAsMF07XHJcbiAgZm9yIChsZXQgaT0wO2k8bjtpKyspe1xyXG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGVzW2ldKTtcclxuICAgIGNvbnN0IHcgPSBkLmdldERheSgpO1xyXG4gICAgY29uc3QgdHJlbmRBdEkgPSBpbnRlcmNlcHQgKyBzbG9wZSAqIGk7XHJcbiAgICBjb25zdCByZXNpZHVhbCA9IHZhbHVlc1tpXSAtIHRyZW5kQXRJO1xyXG4gICAgd2Vla2RheVN1bXNbd10gKz0gcmVzaWR1YWw7XHJcbiAgICB3ZWVrZGF5Q291bnRbd10gKz0gMTtcclxuICB9XHJcbiAgY29uc3Qgd2Vla2RheUF2ZyA9IHdlZWtkYXlTdW1zLm1hcCgocyxpKSA9PiB3ZWVrZGF5Q291bnRbaV0gPyBzL3dlZWtkYXlDb3VudFtpXSA6IDApO1xyXG5cclxuICAvLyA1KSBjb21wdXRlIHJlc2lkdWFscyBkaXN0cmlidXRpb24gKGFmdGVyIHJlbW92aW5nIHRyZW5kK3NlYXNvbmFsaXR5KVxyXG4gIGNvbnN0IHJlc2lkdWFsczogbnVtYmVyW10gPSBbXTtcclxuICBmb3IgKGxldCBpPTA7aTxuO2krKyl7XHJcbiAgICBjb25zdCBkID0gbmV3IERhdGUoZGF0ZXNbaV0pO1xyXG4gICAgY29uc3QgdyA9IGQuZ2V0RGF5KCk7XHJcbiAgICBjb25zdCBwcmVkID0gaW50ZXJjZXB0ICsgc2xvcGUgKiBpICsgd2Vla2RheUF2Z1t3XTtcclxuICAgIHJlc2lkdWFscy5wdXNoKHZhbHVlc1tpXSAtIHByZWQpO1xyXG4gIH1cclxuICBjb25zdCByZXNpZE1lYW4gPSByZXNpZHVhbHMucmVkdWNlKChhLGIpPT5hK2IsMCkvcmVzaWR1YWxzLmxlbmd0aDtcclxuICBjb25zdCByZXNpZFN0ZCA9IE1hdGguc3FydChyZXNpZHVhbHMucmVkdWNlKChhLGIpPT5hKyhiLXJlc2lkTWVhbikqKGItcmVzaWRNZWFuKSwwKS9NYXRoLm1heCgxLHJlc2lkdWFscy5sZW5ndGgtMSkpO1xyXG5cclxuICAvLyA2KSBwcmVkaWN0aXZlIG1lZGlhbiAoZGV0ZXJtaW5pc3RpYyB0cmVuZCtzZWFzb25hbGl0eSkgKyBNb250ZSBDYXJsbyBzaW1zXHJcbiAgY29uc3Qgc2ltcyA9IDMwMDtcclxuICBjb25zdCBydW5zOiBudW1iZXJbXVtdID0gW107IC8vIHNpbXVsYXRpb25zIHggZGF5c1xyXG4gIGZvciAobGV0IHM9MDtzPHNpbXM7cysrKXtcclxuICAgIGNvbnN0IHJ1bjogbnVtYmVyW10gPSBbXTtcclxuICAgIGZvciAobGV0IGk9MDtpPGRheXM7aSsrKXtcclxuICAgICAgLy8gZnV0dXJlIGluZGV4ID0gbiArIGlcclxuICAgICAgY29uc3QgaWR4ID0gbiArIGk7XHJcbiAgICAgIGNvbnN0IGJhc2UgPSBpbnRlcmNlcHQgKyBzbG9wZSAqIGlkeDtcclxuICAgICAgLy8gd2Vla2RheSBmb3IgZnV0dXJlIGRheVxyXG4gICAgICBjb25zdCBmdXREYXRlID0gbmV3IERhdGUoZGF0ZXNbZGF0ZXMubGVuZ3RoLTFdKTtcclxuICAgICAgZnV0RGF0ZS5zZXREYXRlKGZ1dERhdGUuZ2V0RGF0ZSgpICsgMSArIGkpO1xyXG4gICAgICBjb25zdCB3ID0gZnV0RGF0ZS5nZXREYXkoKTtcclxuICAgICAgY29uc3Qgc2Vhc29uYWwgPSB3ZWVrZGF5QXZnW3ddO1xyXG4gICAgICAvLyBzYW1wbGUgcmVzaWR1YWwgbm9pc2VcclxuICAgICAvLyBjbGFtcCBub2lzZSB0byDCsTPPg1xyXG4gICAgIGNvbnN0IG5vaXNlID0gTWF0aC5tYXgoTWF0aC5taW4ocmFuZG4ocmVzaWRNZWFuLCByZXNpZFN0ZCksIHJlc2lkU3RkKjMpLCAtcmVzaWRTdGQqMyk7XHJcbiAgICAgIHJ1bi5wdXNoKGJhc2UgKyBzZWFzb25hbCArIG5vaXNlKTtcclxuICAgIH1cclxuICAgIHJ1bnMucHVzaChydW4pO1xyXG4gIH1cclxuXHJcbiAgLy8gY29tcHV0ZSBtZWRpYW4gYW5kIGludGVydmFscyBmb3IgZWFjaCBkYXlcclxuICBjb25zdCBwb2ludHM6IEZvcmVjYXN0UG9pbnRbXSA9IFtdO1xyXG4gIGZvciAobGV0IGRheUlkeCA9IDA7IGRheUlkeCA8IGRheXM7IGRheUlkeCsrKSB7XHJcbiAgICBjb25zdCB2YWxzID0gcnVucy5tYXAociA9PiByW2RheUlkeF0pLnNvcnQoKGEsYik9PmEtYik7XHJcbiAgICBjb25zdCBtZWRpYW4gPSB2YWxzW01hdGguZmxvb3IodmFscy5sZW5ndGgvMildO1xyXG4gICAgY29uc3QgbG93ZXIgPSB2YWxzW01hdGguZmxvb3IodmFscy5sZW5ndGgqMC4wNSldO1xyXG4gICAgY29uc3QgdXBwZXIgPSB2YWxzW01hdGguZmxvb3IodmFscy5sZW5ndGgqMC45NSldO1xyXG4gICAgY29uc3QgZnV0RGF0ZSA9IG5ldyBEYXRlKGRhdGVzW2RhdGVzLmxlbmd0aC0xXSk7XHJcbiAgICBmdXREYXRlLnNldERhdGUoZnV0RGF0ZS5nZXREYXRlKCkgKyAxICsgZGF5SWR4KTtcclxuICAgIHBvaW50cy5wdXNoKHsgZGF0ZTogZm9ybWF0RGF0ZShmdXREYXRlKSwgbWVkaWFuLCBsb3dlciwgdXBwZXIgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBwcm9qZWN0ZWRNb250aGx5OiBhdmVyYWdlIG9mIGZpcnN0IDMwIG1lZGlhbiBkYXlzIChpZiBhdmFpbGFibGUpXHJcbiAgY29uc3QgZmlyc3QzMCA9IHBvaW50cy5zbGljZSgwLCAzMCk7XHJcbiAgY29uc3QgZGFpbHlBdmcgPSBmaXJzdDMwLnJlZHVjZSgocyxwKT0+cyArIChwLm1lZGlhbiA/PyAwKSwgMCkgLyBmaXJzdDMwLmxlbmd0aDtcclxuICBjb25zdCBwcm9qZWN0ZWRNb250aGx5ID0gZGFpbHlBdmcgKiAzMDsgLy8gYXBwcm94aW1hdGUgbW9udGhseVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcG9pbnRzLFxyXG4gICAgbWV0YToge1xyXG4gICAgICBzbG9wZSxcclxuICAgICAgaW50ZXJjZXB0LFxyXG4gICAgICByZXNpZFN0ZCxcclxuICAgICAgcmVzaWR1YWxDb3VudDogcmVzaWR1YWxzLmxlbmd0aCxcclxuICAgICAgYXZnTW9udGhseSxcclxuICAgICAgcHJvamVjdGVkTW9udGhseVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInBhcnNlRGF0ZU9ubHkiLCJkIiwidCIsIkRhdGUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImZvcm1hdERhdGUiLCJ0b0lTT1N0cmluZyIsInNsaWNlIiwiYnVpbGREYWlseVNlcmllc0Zyb21UcmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbnMiLCJtYXAiLCJmb3JFYWNoIiwiZGF5IiwiZGF0ZSIsImFtb3VudCIsImxpbmVhclJlZ3Jlc3Npb24iLCJ4cyIsInlzIiwibiIsImxlbmd0aCIsInNsb3BlIiwiaW50ZXJjZXB0IiwibWVhblgiLCJyZWR1Y2UiLCJhIiwiYiIsIm1lYW5ZIiwibnVtIiwiZGVuIiwiaSIsInJhbmRuIiwibWVhbiIsInN0ZCIsInUiLCJ2IiwiTWF0aCIsInJhbmRvbSIsInNxcnQiLCJsb2ciLCJjb3MiLCJQSSIsImZvcmVjYXN0IiwiZGF5cyIsInNjZW5hcmlvIiwidHhzIiwiY2F0ZWdvcnkiLCJhdmdNb250aGx5IiwiZGF0ZXMiLCJtaW5EYXRlIiwibWluIiwiZ2V0VGltZSIsIm1heERhdGUiLCJtYXgiLCJtb250aHMiLCJ0b3RhbCIsInMiLCJ0eCIsIk9iamVjdCIsImtleXMiLCJzb3J0IiwicG9pbnRzIiwidG9kYXkiLCJzZXREYXRlIiwicHVzaCIsIm1lZGlhbiIsImxvd2VyIiwidXBwZXIiLCJtZXRhIiwibm90ZXMiLCJwcm9qZWN0ZWRNb250aGx5IiwidmFsdWVzIiwiXyIsIndlZWtkYXlTdW1zIiwid2Vla2RheUNvdW50IiwidyIsImdldERheSIsInRyZW5kQXRJIiwicmVzaWR1YWwiLCJ3ZWVrZGF5QXZnIiwicmVzaWR1YWxzIiwicHJlZCIsInJlc2lkTWVhbiIsInJlc2lkU3RkIiwic2ltcyIsInJ1bnMiLCJydW4iLCJpZHgiLCJiYXNlIiwiZnV0RGF0ZSIsInNlYXNvbmFsIiwibm9pc2UiLCJkYXlJZHgiLCJ2YWxzIiwiciIsImZsb29yIiwiZmlyc3QzMCIsInAiLCJkYWlseUF2ZyIsInJlc2lkdWFsQ291bnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/forecast.ts\n"));

/***/ })

});